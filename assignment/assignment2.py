{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-3cdb23b066a3b3f6",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "# Assignment 2\n",
    "\n",
    "* This assignment includes some tests to help you make sure that your implementation is correct.  When you see a cell with `assert` commands, these are tests.\n",
    "\n",
    "* Once you have completed the assignment, delete the cells which have these `assert` commands.  You will not need them.\n",
    "\n",
    "* When you are done and have answered all the questions, convert this notebook to a .py file using `File > Download as > Python (.py)`.  Name your submission `assignment2.py` and submit it to OWL.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#It's dangerous to go alone.  Take these!\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "from scipy.optimize import minimize\n",
    "from scipy.special import factorial\n",
    "from scipy.stats import linregress\n",
    "from scipy.special import gammaln\n",
    "from scipy.stats import poisson\n",
    "import pytest"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-52cc9d23492f513d",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "## Maximum Likelihood\n",
    "\n",
    "The poisson distribution https://en.wikipedia.org/wiki/Poisson_distribution is a discrete probability distribution often used to describe count-based data, like how many snowflakes fall in a day.\n",
    "\n",
    "If we have count data $y$ that are influenced by a covariate or feature $x$, we can used the maximum likelihood principle to develop a regression model relating $x$ to $y$.\n",
    "\n",
    "### Question 1\n",
    "Write a function called `poissonNegLogLikelihood` that takes a count `y` and a parameter `lam` and produces the negative log likelihood of `y` assuming that it was generated by a Poisson distribution with parameter `lam`. You may also want to use `scipy.misc.gammaln` to compute the log of a factorial.  The Gamma Function, $\\Gamma(x)$, is a sort of generalized factorial, and `gammaln` efficiently computes the natural log of the Gamma Function.\n",
    "\n",
    "It is worth noting that $\\Gamma(x) \\neq x!$ so it might be worth your while to do a little reading on the gamma function before implementing this function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-53453625403f20d1",
     "locked": false,
     "schema_version": 1,
     "solution": true
    }
   },
   "outputs": [],
   "source": [
    "def poissonNegLogLikelihood(lam, y):\n",
    "    \"\"\"\n",
    "    Computes the negative log-likelihood for a Poisson random variable.\n",
    "\n",
    "    Inputs:\n",
    "    lam - float or array.  Parameter for the poisson distribution.\n",
    "    y - float or array.  Observed data.\n",
    "\n",
    "    Outputs:\n",
    "    log_lik - float.  The negative log-likelihood for the data (y) with parameter (lam).\n",
    "\n",
    "    \"\"\"\n",
    "    ### BEGIN SOLUTION\n",
    " \n",
    "    log_lik = -np.sum(-lam + (y*np.log(lam))-((gammaln(y+1))))\n",
    "    if np.all(lam ==0) :  \n",
    "        if np.all(y ==0):\n",
    "            np.isinf(log_lik) \n",
    "        np.isnan(log_lik) \n",
    "    ### END SOLUTION\n",
    "    return log_lik\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-8b1c4015e09e7adc",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Tests\n",
    "\n",
    "One of the comments we recieved from the first assignment is that there were few obvious ways to check if the function you've written is working correctly.  This is an approach to address those concerns!\n",
    "\n",
    "Now that you've written the `poissonNegLogLikelihood`, let's test to see if it works.  Below are 3 `assert` statements.  They return nothing if your implementation does what it is supposed to do and raise an error if there is an error.  If you can run this cell and don't see an `AssertionError`, your implementation produces numbers when it's supposed to and does not produce numbers when it isn't supposed to (the tests say nothing about whether the numbers are correct.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-3d1415c1b5320814",
     "locked": true,
     "points": 1,
     "schema_version": 1,
     "solution": false
    }
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/tljh/user/lib/python3.6/site-packages/ipykernel_launcher.py:15: RuntimeWarning: divide by zero encountered in log\n",
      "  from ipykernel import kernelapp as app\n",
      "/opt/tljh/user/lib/python3.6/site-packages/ipykernel_launcher.py:15: RuntimeWarning: invalid value encountered in double_scalars\n",
      "  from ipykernel import kernelapp as app\n"
     ]
    }
   ],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-76bf0b24b4841f8c",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "Here are some more tests that check the values your function produces.  These are graded tests, but you can see what the answer should be ahead of time.  There are also some tests that are not shown to you at the moment.  If your `poissonNegLogLikelihood` is working, then this cell should run without any errors.\n",
    "\n",
    "Once you are satisfied with your implementation of `poissonLogLikelihood`, please delete the cell below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-ae610e040f94800b",
     "locked": true,
     "points": 1,
     "schema_version": 1,
     "solution": false
    }
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-e1536169f75db24f",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Question 2\n",
    "\n",
    "Write a function called `poissonMLE` which accepts as it's first argument an array of data `data` and returns the maximum likelihood estimate for a poisson distribution $\\lambda$.  You should use `scipy.optimize.minimize`. You don't have to calculate gradients for this example."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-8be43b21b85443c0",
     "locked": true,
     "points": 0,
     "schema_version": 1,
     "solution": false
    }
   },
   "outputs": [],
   "source": [
    "def poisson_mle(data):\n",
    "    \"\"\"\n",
    "    Compute the maximum likelihood estimate (mle) for a poisson distribution given data.\n",
    "\n",
    "    Inputs:\n",
    "    data - float or array.  Observed data.\n",
    "\n",
    "    Outputs:\n",
    "    lambda_mle - float.  The mle for poisson distribution.\n",
    "    \"\"\"\n",
    "    ### BEGIN SOLUTION    \n",
    "    lambda_mle = minimize(poissonNegLogLikelihood, 1 ,args =(data))\n",
    "    lambda_mle = lambda_mle.x[0]\n",
    "    ### END SOLUTION\n",
    "    return lambda_mle"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, here are some tests for `poisson_mle`.  If you pass these tests, then that should mean your function is working.  You can also write your own tests to make sure the function is working.  Once you are happy with your implmentation, please delete the cell below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-794356f507d03d2b",
     "locked": true,
     "points": 1,
     "schema_version": 1,
     "solution": false
    }
   },
   "outputs": [],
   "source": [
    "# Here are some tests for your function\n",
    "# If you pass all of these, that is good evidence that your function is working.\n",
    "data = 1.0\n",
    "lambda_mle = poisson_mle(data)\n",
    "# lambda_mle should be a float and should be larger than 0\n",
    "# Test 1\n",
    "assert isinstance(lambda_mle, float) & (lambda_mle > 0)\n",
    "# Test 2\n",
    "assert np.isclose(lambda_mle, 1.0, rtol=1e-2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-997a2577c12981ba",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Question 3\n",
    "\n",
    "Write a function called `poissonRegressionLogLikelihood` that takes a vector $\\mathbf{y}$ of counts, a design matrix $\\mathbf{X}$ of features for each count (including a column of 1s for the intercept), and a vector $\\mathbf{b}$ of parameters. The function should compute the likelihood of this dataset, assuming that each $y$ is independently distributed with a poisson distribution with parameter $\\lambda = exp(X\\beta)$.  That is to say, your function should work in the general case for $n$ obervations and $p$ parameters.\n",
    "\n",
    "Hint: You can use `poissonNegLogLikelihood` in this answer!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-0ce8e86fb1602e7f",
     "locked": true,
     "points": 0,
     "schema_version": 1,
     "solution": false
    }
   },
   "outputs": [],
   "source": [
    "def poissonRegressionNegLogLikelihood(b, X, y):\n",
    "    \"\"\"\n",
    "    Computes the negative log-likelihood for a poisson regression.\n",
    "\n",
    "    Inputs:\n",
    "    b - array.  Coefficients for the poisson regression\n",
    "    X - array.  Design matrix.\n",
    "    y - array.  Observed outcomes.\n",
    "\n",
    "    Outputs:\n",
    "    log_lik - float.  Negative log likelihood for the poisson regression with coefficients b.\n",
    "\n",
    "    \"\"\"\n",
    "    ### BEGIN SOLUTION\n",
    "    lambda_n = np.exp(X@b).reshape(-1,1)\n",
    "    log_lik = poissonNegLogLikelihood(lambda_n,y)\n",
    "    ### END SOLUTION\n",
    "    return log_lik"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-293b103a8777b257",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Question 4\n",
    "\n",
    "In `poissonRegressionNegLogLikelihood`, why did we apply the exponential function to the linear predictor?  What might have happened had we just passed $\\lambda =X\\beta$?  Enter your answer below in markdown."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 5\n",
    "\n",
    "Write a function called `fitPoissonRegression` which takes as its first argument data `x` and as its second argument outcomes `y` and returns the coefficients for a poisson regression."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fitPoissonRegression(X, y):\n",
    "    \"\"\"\n",
    "    Fits a poisson regression given data and outcomes.\n",
    "\n",
    "    Inputs:\n",
    "    X - array.  Design matrix\n",
    "    y - array.  Observed outcomes\n",
    "\n",
    "    Outputs:\n",
    "    betas_est - array.  Coefficients which maximize the negative log-liklihood.\n",
    "    \"\"\"\n",
    "    ### BEGIN SOLUTION\n",
    "    nrows,ncols = X.shape\n",
    "    betas=np.zeros((ncols,1))\n",
    "    RES = minimize(poissonRegressionNegLogLikelihood,betas,args=(X,y))\n",
    "    betas_est=RES.x\n",
    "    ### END SOLUTION\n",
    "    return betas_est"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-a9fd51947c881221",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Question 6\n",
    "\n",
    "Write a function called `makePoissonRegressionPlot` which loads in the data from `poisson_regression_data.csv`, plots a scatterplot of the data, fits a poisson regression to this data, plots the model predictions over $x \\in [-2,2]$, and then saves the plot under the file name `poisson_regression.png`.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "poisson_regression=pd.read_csv('poisson_regression_data.csv')\n",
    "\n",
    "\n",
    "    ### BEGIN SOLUTION\n",
    "def makePoissonRegressionPlot():\n",
    "    fig, ax = plt.subplots(dpi = 120)\n",
    "    poisson_regression.plot.scatter(x = 'x', \n",
    "                                    y = 'y', \n",
    "                                    alpha = 0.75,\n",
    "                                    ax = ax)\n",
    "    \n",
    "    y = poisson_regression.y.values\n",
    "    x = poisson_regression.x.values\n",
    "\n",
    "    N = x.size\n",
    "    X = np.c_[np.ones(N), x]\n",
    "    actual_betas = fitPoissonRegression(X,y)\n",
    "\n",
    "    x_grid =  np.arange(x.min(), x.max())\n",
    "    Xn = np.c_[np.ones(x_grid.size), x_grid]\n",
    "    Yn = Xn@ actual_betas\n",
    "\n",
    "    ax.plot(x_grid, Yn, color = 'red')\n",
    "    plt.savefig('poisson_regression.png')\n",
    "\n",
    "    ### END SOLUTION\n",
    "    # This function does not have to return anything\n",
    "    return None\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": false,
     "grade_id": "cell-60bc43f590423573",
     "locked": true,
     "schema_version": 1,
     "solution": false
    }
   },
   "source": [
    "### Question 7\n",
    "\n",
    "Write a function called `makeLinearRegressionPlot`  which loads in the data from `poisson_regression_data.csv`, plots a scatterplot of the data, fits a linear regression to this data, plots the model predictions over $x \\in [-2,2]$, and then saves the plot under the file name `linear_regression.png`. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-eba2c3c0a596b3fb",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "outputs": [],
   "source": [
    "poisson_regression=pd.read_csv('poisson_regression_data.csv')\n",
    "\n",
    "def makeLinearRegressionPlot():\n",
    "    ### BEGIN SOLUTION\n",
    "    fig, ax = plt.subplots(dpi = 120)\n",
    "    poisson_regression.plot.scatter(x = 'x', \n",
    "                                    y = 'y', \n",
    "                                    alpha = 0.75,\n",
    "                                    ax = ax)\n",
    "    slope, intercept, r_value, p_value, std_err = linregress(x, y)\n",
    "    plt.plot(x, intercept + slope*x, 'r', label='fitted line')\n",
    "    plt.savefig('linear_regression.png')\n",
    "    \n",
    "    ### END SOLUTION\n",
    "    # This function does not have to return anything\n",
    "    return None\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-7b294a6a4f8afdab",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "source": [
    "### Question 8\n",
    "\n",
    "\n",
    "1) Explain in 2 or 3 sentences why the coefficients from OLS are different from those from Poisson regression.\n",
    "\n",
    "2) Explain in 2 or 3 sentences why the predicted mean counts are different. Do you see any major problems with the predictions from OLS?\n",
    "\n",
    "Provide your answer below in markdown\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "nbgrader": {
     "grade": true,
     "grade_id": "cell-a83217c69319fb8b",
     "locked": false,
     "points": 0,
     "schema_version": 1,
     "solution": true
    }
   },
   "source": [
    "Your answer here:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#q4)We have to use exponential in this poissonregressionnegloglikelihood because if we just use lambda = Xb then it will not compute the likelihood because it will prduce a rounding error that is very large. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1) OLS and Poisson regrression has different coefficient because OLS is unbiased. Also, in poisson regression, we use likelihood function to find estimates of the model coefficient. so that means we use maximum likelihood so that the data is maximized.   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#2)I believe that major problems with the predictions from OLS is when the assumption is not met well so we have to check again with other predictions. Also, the outliers are effective large in the predictions.  "
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Create Assignment",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
